C51 COMPILER V8.06   LCD                                                                   01/22/2018 12:10:05 PAGE 1   


C51 COMPILER V8.06, COMPILATION OF MODULE LCD
OBJECT MODULE PLACED IN LCD.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE LCD.c OPTIMIZE(9,SIZE) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include"head.h"
   2          
   3          uchar seg[4]={0,0,0,0x0a};
   4          /*////////////////
   5          注意以下方法适用于P1.0接SEG1(接口5），P1.5接SEG6（接口10），如果反过来，那么calSEG函数中最后的位颠倒运算可
             -以取消
   6          *//////////////
   7          
   8          
   9          void calSEG(int n)
  10          {
  11   1              uchar digit[2];
  12   1              uchar i,j,old,new;
  13   1              uchar lcdCode[]={0x77,0x14,0x5b,0x5d,0x3c,0x6d,0x6f,0x54,0x7f,0x7d};
  14   1              uchar units,tens;
  15   1              for(i=0;i<4;i++)
  16   1              {
  17   2                      seg[i]=0;
  18   2              }
  19   1              seg[3]=0x0a;
  20   1              if(n<0)
  21   1              {
  22   2                      seg[1]=0x20;
  23   2                      n=-n;
  24   2              }
  25   1              if(n>99)
  26   1              {
  27   2                      seg[0]=0x0;
  28   2                      seg[1]=0x0;
  29   2                      seg[2]=0x0;
  30   2                      seg[3]=0x2a;
  31   2              }
  32   1              else
  33   1              {
  34   2                      digit[0]=n%10;
  35   2                      digit[1]=(n/10)%10;
  36   2                      tens=lcdCode[digit[1]];
  37   2                      units=lcdCode[digit[0]];
  38   2                      seg[0]|=(tens&0x03)<<2  |       (units&0x03);
  39   2                      seg[1]|=(tens&0x0c)             |       (units&0x0c)>>2;
  40   2                      seg[2]|=(tens&0x30)>>2  |       (units&0x30)>>4;
  41   2                      seg[3]|=(tens&0xc0)>>4  |       (units&0xc0)>>6;
  42   2              }
  43   1              //*/取反操作，适用于P1.0接SEG1(接口5），P1.5接SEG6（接口10），如果反过来，那么位颠倒运算可以取消
  44   1              for(i=0;i<4;i++)
  45   1              {
  46   2                      old = seg[i];
  47   2                      new=0;
  48   2                      for(j=0;j<6;j++)
  49   2                      {
  50   3                              new<<=1;
  51   3                              if((old&0x01)==0x01)
  52   3                                      new |= 0x01;
  53   3                              old >>=1;
  54   3                      }
C51 COMPILER V8.06   LCD                                                                   01/22/2018 12:10:05 PAGE 2   

  55   2                      seg[i]=new;
  56   2              }
  57   1      }
  58          
  59          
  60          //*
  61          void lcdShow(int n)
  62          {
  63   1              uchar i,j;
  64   1              uchar highSet[4]={0x0e,0x0d,0x0b,0x07};
  65   1              uchar lowSet[4]={0x01,0x02,0x04,0x08};
  66   1              j=10;
  67   1              calSEG(n);
  68   1              while(j--)
  69   1              {
  70   2                      for(i=0;i<4;i++)
  71   2                      {
  72   3                              P3M1=0x0f;
  73   3                              P3M0=0x00;
  74   3                              P1=seg[i];
  75   3                              P3M1=highSet[i];
  76   3                              P3M0=lowSet[i];
  77   3                              P3=~(0x01<<i);
  78   3                              DelayNms(2);
  79   3                              P3=~P3;
  80   3                              P1=~P1;
  81   3                              DelayNms(2);
  82   3                      }       
  83   2              }
  84   1      
  85   1              
  86   1      }
  87          //*/
  88          /*
  89          void lcdShow(int n)
  90          {
  91                  uchar i,j;
  92                  uchar highSet[4]={0x0e,0x0d,0x0b,0x07};
  93                  uchar lowSet[4]={0x01,0x02,0x04,0x08};
  94                  j=10;
  95                  seg[0]=0x04;
  96                  seg[1]=0x0d;
  97                  seg[2]=0x09;
  98                  seg[3]=0x24;
  99                  
 100                  while(j--)
 101                  {
 102                          for(i=0;i<4;i++)
 103                          {
 104                                  P1=seg[i];
 105                                  P3M1=highSet[i];
 106                                  P3M0=lowSet[i];
 107                                  P3=~(0x01<<i);
 108                                  DelayNms(2);
 109                                  P3=~P3;
 110                                  P1=~P1;
 111                                  DelayNms(2);
 112                          }
 113                  }
 114          
 115          }
 116          //*/
C51 COMPILER V8.06   LCD                                                                   01/22/2018 12:10:05 PAGE 3   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    363    ----
   CONSTANT SIZE    =     18    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      27
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
